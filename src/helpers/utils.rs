use crate::ArithmeticError;
use crate::P;
use crate::arithmetic_operations::{addition, subtract};

/// Helper function to compare if array a is >= b
/// Specifically used to check if 256-bit int is >= P (modulus)
///
/// return true if: a >= b
/// return false if a < b
pub fn is_greater_or_equal(a: &[u8; 32], b: &[u8; 32]) -> bool {
    for i in 0..32 {
        if a[i] > b[i] {
            return true;
        }
        if a[i] < b[i] {
            return false;
        }
    }
    true
}

/// Specifically used to check if 512-bit int is >= P (modulus)
///
/// return true if: a >= b
/// return false if a < b
pub fn is_greater_or_equal_512(a: &[u8; 64], b: &[u8; 64]) -> bool {
    for i in 0..64 {
        if a[i] > b[i] {
            return true;
        }
        if a[i] < b[i] {
            return false;
        }
    }
    true
}

/// Given a dividend and a divisor this function will return q (quotient) and r (remainder)
/// Similar to regular division, ex: 7/3 = 2 remainder 1, but for 256-bit integers
///
/// Dividend: &[u8; 32]
/// Divisor: &[u8; 32]
/// Returns: (q,r) where a = b * q + r, 0 <= r < b
pub fn div_rem(
    dividend: &[u8; 32],
    divisor: &[u8; 32],
) -> Result<([u8; 32], [u8; 32]), ArithmeticError> {
    // Error if dividing by zero
    if *divisor == [0; 32] {
        return Err(ArithmeticError::DivisionByZero);
    }

    // Early return if a < b
    if !is_greater_or_equal(dividend, divisor) {
        return Ok(([0; 32], *dividend));
    }

    // initialize a 32-byte array of value 1
    let mut one_array = [0; 32];
    one_array[31] = 0x01;

    let mut quotient = [0; 32];
    let mut remainder = *dividend;

    // this loop will be slow for big numbers
    // TODO:Optimitize as this currently runs at O(a/b)
    while is_greater_or_equal(&remainder, divisor) {
        remainder = subtract(&remainder, divisor, &P, false);
        quotient = addition(&quotient, &one_array, &P, false);
    }

    Ok((quotient, remainder))
}

// reduce 512-bit number to a 256-bits mod P
pub fn reduce_modulus(full_product: [u8; 64], modulus: [u8; 32]) -> [u8; 32] {
    let mut temp = full_product;
    let padding = [0x00; 32];
    let mut padded_mod = [0u8; 64];
    padded_mod[..32].copy_from_slice(&padding);
    padded_mod[32..].copy_from_slice(&modulus);
    let mut bottom_half: [u8; 32] = temp[32..64].try_into().unwrap();
    let mut top_half: [u8; 32] = temp[0..32].try_into().unwrap();

    // Reduce until top 32 bytes are zero or bottom 32 < modulus
    while top_half != [0; 32] || is_greater_or_equal(&bottom_half, &modulus) {
        if is_greater_or_equal_512(&temp, &padded_mod) {
            temp = subtract_512(temp, padded_mod);
        } else {
            break;
        }
        bottom_half = temp[32..64].try_into().unwrap();
        top_half = temp[0..32].try_into().unwrap();
    }

    if is_greater_or_equal(&bottom_half, &modulus) {
        bottom_half = subtract(&bottom_half, &modulus, &modulus, false)
    }

    return bottom_half;
}

// subtract 2 512-bit u8 arrays
fn subtract_512(a: [u8; 64], b: [u8; 64]) -> [u8; 64] {
    let mut result = [0; 64];
    let mut borrow = 0;

    for i in (0..64).rev() {
        let mut diff = a[i] as u16 - b[i] as u16 - borrow as u16;
        if diff < 0 {
            diff = diff + 256;
            borrow = 1;
        } else {
            borrow = 0;
        }
        result[i] = diff as u8 & 0xFF;
    }
    result
}

// merge 2 u8 arrays into 1 u16 array
fn combine_u8_arrays_to_u16(a: [u8; 32], b: [u8; 32]) -> [u16; 64] {
    let mut result = [0u16; 64];

    for i in 0..32 {
        result[i] = a[i] as u16;
        result[i + 32] = b[i] as u16;
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_greater_or_equal() {
        // 256
        let x1 = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
        ];
        // 512
        let y1 = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00,
        ];

        let x2 = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
        ];

        let y2 = [
            0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
        ];

        assert_eq!(is_greater_or_equal(&x1, &y1), false); // 256 < 512
        assert_eq!(is_greater_or_equal(&y1, &x1), true); // 512 > 256
        assert_eq!(is_greater_or_equal(&x2, &x1), true); // 256 = 256
        assert_eq!(is_greater_or_equal(&y2, &y1), true); // 1.1534 * 10**77  > 512
    }

    #[test]
    fn test_div_rem_division_by_zero() {
        //
        let dividend = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x00, 0x00,
        ];
        // zero
        let divisor = [0; 32];
        assert!(div_rem(&dividend, &divisor).is_err());
    }

    #[test]
    fn test_div_rem_divide_small_numbers() {
        // 10
        let dividend = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x0a,
        ];
        // 3
        let divisor = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x03,
        ];
        // 3
        let quotient = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x03,
        ];
        // 1
        let remainder = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
        ];

        let correct_answer = (quotient, remainder);

        assert_eq!(div_rem(&dividend, &divisor).unwrap(), correct_answer);
    }

    #[test]
    fn test_div_rem_even_numbers() {
        // 7
        let dividend = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x07,
        ];
        // 7
        let divisor = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x07,
        ];
        // 3
        let quotient = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
        ];
        // 1
        let remainder = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];

        let correct_answer = (quotient, remainder);

        assert_eq!(div_rem(&dividend, &divisor).unwrap(), correct_answer);
    }

    #[test]
    fn test_div_rem_small_dividend() {
        // 5
        let dividend = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x05,
        ];
        // 6
        let divisor = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x06,
        ];
        // 0
        let quotient = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00,
        ];
        // 5
        let remainder = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x05,
        ];

        let correct_answer = (quotient, remainder);

        assert_eq!(div_rem(&dividend, &divisor).unwrap(), correct_answer);
    }

    #[test]
    fn test_div_rem_large_numbers() {
        // initialize a 32-byte array of value 1
        let mut one = [0; 32];
        one[31] = 0x01;
        // P
        let dividend = &P;
        // P - 1
        let divisor = subtract(&P, &one, &P, false); // P - 1
        // 1
        let quotient = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
        ];
        // 1
        let remainder = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x01,
        ];

        let correct_answer = (quotient, remainder);

        assert_eq!(div_rem(&dividend, &divisor).unwrap(), correct_answer);
    }
}
