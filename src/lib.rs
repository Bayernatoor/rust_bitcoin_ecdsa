use sha2;

// Elliptic curve formula = y**2 = x**3 + ax + b
//
// Bitcoin's EC is more like a scatter plot
// It's an EC over a finite field of whole numbers (mod p)
// It restricts the numbers to within a certain range
//
// The curve used in bitcoin is secp256k1

// Building blocks of ECDSA is:
// Parameters of secp256k1 curve (bitcoin's EC)
// Modular inverse -
// Add -
// Double -
// Multiply -

// Secp256k1 curve parameters
// Using section 2.4.1 to set the parameters -> https://www.secg.org/sec2-v2.pdf
// y² = x³ + ax + b
pub const A: [u8; 32] = [0x00; 32];
pub const B: [u8; 32] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
];

// Finite Field prime number (field size); size of the finite field
// In decimal = 115792089237316195423570985008687907853269984665640564039457584007908834671663
pub const P: [u8; 32] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f,
];

// Order of the Secp256k1 curve; number of points on the curve
// In decimal = 115792089237316195423570985008687907852837564279074904382605163141518161494337
pub const N: [u8; 32] = [
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41,
];

// X coordinate of the generator
// In decimal = 55066263022277343669578718895168534326250603453777594175500187360389116729240
pub const GENERATOR_X: [u8; 32] = [
    0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07,
    0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98,
];

// Y coordinate of the generator
// In decimal = 32670510020758816978083085130507043184471273380659243275938904335757337482424
pub const GENERATOR_Y: [u8; 32] = [
    0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8,
    0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8,
];

// G constant (generator point) - all calculations start with this point
pub const G: (&[u8; 32], &[u8; 32]) = (&GENERATOR_X, &GENERATOR_Y);

pub enum EcdsaError {}

#[cfg(test)]
mod tests {
    use super::*;

    //#[test]
    //fn multiply() {
    //    let result = add(2, 2);
    //    assert_eq!(result, 4);
    //}
}
